!BM--------------------------------------------------------------------
Module setpar

Contains

  !BS-----------------------------------------------------------------
  subroutine setparam
  use var
  use var_analyze
  implicit none
  integer::iargc  ! intrinsic function
  character*100::string

  !--------------------------------------------------------
  !Check if input file is specified else use default "input"
  !Specification of file is given by the user's execute
  !command "./DNATS.exe input_filename". Also an output
  !filename can be specified by the user by
  !"./DNATS.exe input_filename > output_filename"   
  !Otherwise all "print *" lines will appear on the screen
  !--------------------------------------------------------

  inp_flnm="input"  !Default filename
  inp_flnm=trim(dir)//"/md/input"
  print *,"input file: """,trim(inp_flnm), """"  
  

  !remove possible "EXIT" file
  !set random number generator variables
  call random_seed(size=isze) ! determine length of seed-array
                              ! random number generator
  allocate(iseedarr(isze))
  iseedarr=0
  !IF RESTART is specified then iseedarr will be read from the restart file
  !later on

  !Before reading from input file set all default values
  call set_defaults

  !read data from the input file "input.data"
  call read_input

  print *,""
  print *,"read sequence from file: ", seqfile
  call read_sequence

  !set all variables that depend on input and default parameters
  call set_depvariables

  end subroutine setparam
  !ES-----------------------------------------------------------------

  !BS------------------------------------------------------------------
  subroutine set_defaults
  use var
  implicit none
  double precision::evJ

  evJ=1.60219D-19
  print *,""
  print *,"setting physical constants"
  !kb = 8.61758d-05  ! Boltzman constant in eV/K
  kb=1.3807D-23     ! J/K
  print *,"kb=", kb, " J/K"
  kb=kb/evJ
  print *,"kb=", kb, " eV/K"

  Nbase=10
  mass=300.
  PBC=.false.
  BIAS=.false.
  RENUMBER=.false.
  seqfile="seq.0001"
  dAT = 0.05d0; dGC = 0.075d0; aAT = 4.2d0; aGC = 6.9d0
  Temp=1.d0
  S= 0.025d0 
  rho = 2.0d0 
  alpha = 0.35d0
  dt= 0.1d0
  !Defaults for movie, unimportant for the calculation
  Mfac=1.d0
  Mdx=1.;Mdy=-1.
  doublechain=.false.
  MtypAT="Au"
  MtypGC="C "

  !BIAS
  N_expB=6.
  Rc=1.
  

  !initializing timesteps and main MD loop length
  NMD=100
  skip=1
  
  !Thermostats
  THERMOS="NONE"
  AndersFreq = 0.001
  Nthermo=2

  !order parameter
  y_open=1.
  y_open2=.99
  k_open=10.

  !interfaces
  lam0=0.2
  lam1=0.5
  lam2=0.99
  
 
  !path parameters
  MAXLEN=10000
  sigma=0.1
  gamma=0.5d0
  NMC=10
  pskip=1

  !RESTART (yes/NO) 
  RESTART=.false.

  !save extended path information (can cost lot of memory on the harddisk)
  savepaths=.false.
  saveallpaths=.false.
  PPTIS=.false.

  end subroutine set_defaults
  !ES------------------------------------------------------------------  

  !BS-----------------------------------------------------------------
  subroutine read_input
  use var
  use filrea
  implicit none
  character*100::string
  character*3::typ
  double precision::dp
  integer::integ,iL
 
    call countlines(inp_flnm,NLinp)
    print *,"number of lines input file:",NLinp 

    !search for task, either MD or PATHSAMPLING
    TASK="NONE"
    string="MD"
    call check_string(inp_flnm,1,NLinp,string,iL)
    if (iL/=0) TASK=string
    string="PATHSAMPLING"
    call check_string(inp_flnm,1,NLinp,string,iL)
    if (iL/=0) TASK=string 
    if (TASK=="NONE") then
      print *,"Task is not specified in file ",inp_flnm
      print *, "This should by either MD or PATHSAMPLING"
      stop
    endif
    print *,""
    print *,"TASK=",TASK
    print *,""
    
    print *,"Specified parameters in input file overwrite default values"
    print *,"Following paramters are set:"
    print *,""

    !read character* strings
    string="seq."
    call check_string(inp_flnm,1,NLinp,string,iL) 
    if (iL/=0)  call read_fileln_string(inp_flnm,iL,seqfile)
    print *,"sequence file= ",seqfile
    string="RESTART"
    call check_string(inp_flnm,1,NLinp,string,iL)
    if (iL/=0)  then 
       call read_fileln_string(inp_flnm,iL,RESTARTF)
       RESTART=.true.
       print *,"RESTART file= ",RESTARTF
    endif
    print *,"RESTART: ",RESTART
    string="ANDERSEN" 
    call check_string(inp_flnm,1,NLinp,string,iL)
    if (iL/=0) Thermos="ANDERSEN"
    string="NOSEHOOVER"
    call check_string(inp_flnm,1,NLinp,string,iL)
    if (iL/=0) Thermos="NOSEHOOVER"
    print *,"Thermostat:",Thermos 

    !read logicals
    string="PBC"
    call check_string(inp_flnm,1,NLinp,string,iL)
    if (iL/=0) PBC=.true.
    print *,"PBC=",PBC
    string="doublechain"
    call check_string(inp_flnm,1,NLinp,string,iL)
    if (iL/=0) doublechain=.true.
    print *,"doublechain=",doublechain
    !has only visualization importance
    !makes a symetric double chain as movie in xyz-format
    string="savepaths"
    call check_string(inp_flnm,1,NLinp,string,iL)
    if (iL/=0) savepaths=.true.
    print *,"savepaths=",savepaths
    string="saveallpaths"
    call check_string(inp_flnm,1,NLinp,string,iL)
    if (iL/=0) saveallpaths=.true.
    print *,"saveallpaths=",saveallpaths
    string="RENUMBER"
    call check_string(inp_flnm,1,NLinp,string,iL)
    if (iL/=0) RENUMBER=.true.
    string="BIAS"
    call check_string(inp_flnm,1,NLinp,string,iL)
    if (iL/=0) BIAS=.true.
    print *,"BIAS=",BIAS
    string="PPTIS"
    call check_string(inp_flnm,1,NLinp,string,iL)
    if (iL/=0) PPTIS=.true.
    print *,"PPTIS=",PPTIS


    !read integer values
    typ="int";dp=0.d0
    string= "Nbase" ; call getval(inp_flnm,string,1,NLinp,typ,dp,Nbase)
    string="NMD"    ; call getval(inp_flnm,string,1,NLinp,typ,dp,NMD)
    string="Nthermo"; call getval(inp_flnm,string,1,NLinp,typ,dp,Nthermo)
    string="skip"   ; call getval(inp_flnm,string,1,NLinp,typ,dp,skip)
    string="pskip"   ; call getval(inp_flnm,string,1,NLinp,typ,dp,pskip)
    string="MAXLEN" ; call getval(inp_flnm,string,1,NLinp,typ,dp,MAXLEN)
    string="NMC"    ; call getval(inp_flnm,string,1,NLinp,typ,dp,NMC)

    !read double precision values
    typ="dp";integ=0
    string="mass"   ; call getval(inp_flnm,string,1,NLinp,typ,mass,integ)
    string="dAT"    ; call getval(inp_flnm,string,1,NLinp,typ,dAT,integ)
    string="dGC"    ; call getval(inp_flnm,string,1,NLinp,typ,dGC,integ)
    string="aAT"    ; call getval(inp_flnm,string,1,NLinp,typ,aAT,integ)
    string="aGC"    ; call getval(inp_flnm,string,1,NLinp,typ,aGC,integ)
    string="Temp"   ; call getval(inp_flnm,string,1,NLinp,typ,Temp,integ)
    string="S"      ; call getval(inp_flnm,string,1,NLinp,typ,S,integ)
    string="rho"    ; call getval(inp_flnm,string,1,NLinp,typ,rho,integ)
    string="alpha"  ; call getval(inp_flnm,string,1,NLinp,typ,alpha,integ)
    string="dt"     ; call getval(inp_flnm,string,1,NLinp,typ,dt,integ)
    string="Mfac"   ; call getval(inp_flnm,string,1,NLinp,typ,Mfac,integ)
    string="Mdx"    ; call getval(inp_flnm,string,1,NLinp,typ,Mdx,integ)
    string="Mdy"    ; call getval(inp_flnm,string,1,NLinp,typ,Mdy,integ)
 string="AndersFreq";call getval(inp_flnm,string,1,NLinp,typ,AndersFreq,integ)
    string="y_open" ; call getval(inp_flnm,string,1,NLinp,typ,y_open,integ)
    string="y_open2"; call getval(inp_flnm,string,1,NLinp,typ,y_open2,integ)
    string="k_open" ; call getval(inp_flnm,string,1,NLinp,typ,k_open,integ)
    string="lam0"   ; call getval(inp_flnm,string,1,NLinp,typ,lam0,integ)
    string="lam1"   ; call getval(inp_flnm,string,1,NLinp,typ,lam1,integ)
    string="lam2"   ; call getval(inp_flnm,string,1,NLinp,typ,lam2,integ)
    string="sigma"  ; call getval(inp_flnm,string,1,NLinp,typ,sigma,integ)
    string="gamma"  ; call getval(inp_flnm,string,1,NLinp,typ,gamma,integ)
    string="N_expB" ; call getval(inp_flnm,string,1,NLinp,typ,N_expB,integ)
    string="Rc"     ; call getval(inp_flnm,string,1,NLinp,typ,Rc,integ)


  end subroutine read_input
  !ES-----------------------------------------------------------------

  !B------------------------------------------------------------------
  subroutine  set_depvariables
  use var
  implicit none
  integer::i
  double precision:: ommax2, sigma_w

  kbT=kb*Temp
  beta=1.d0/kbT                !inverse temperature
  sigma_p=sqrt(mass*kbT)       !width of gaussian momenta distr.
  sigma_v=sqrt(kbT/mass)       !width of gaussian velocity distr.
  sigma_w=sqrt(kbT)            !width of mass-weighted velocity distr.
  print *,"sigma_w=sqrt(kbT)",sigma_w
  sigma=sigma*sigma_w
  print *,"sigma=sigma*sigma_w=",sigma

  Tmd=NMD*NMD

  allocate(Q_Nose(Nthermo))
  allocate(xi(Nthermo)) 
  allocate(vxi(Nthermo))
  xi=0.d0;vxi=0.d0
  !optimization for setting Nose-Hoover chain masses
  !First the highest harmonic frequency in the system
  !Then Q(1)=(Nf kb T)/omega**2 and others Q(i)=(kb T)/omega**2
  !With Nf=dN the degrees of freedom
  !See Martyna et al Mol Phys. 87, 1117 (1996)
  ommax2 = (2.0d0*dGC*aGC**2 + 4.0d0*s)/mass
  Q_NOSE(1:Nthermo)=(kb*Temp)/ ommax2
  Q_NOSE(1)= Q_nose(1)*Nbase
  dt2=dt/2
  dt4=dt/4
  dt8=dt/8

  dt2m=0.5d0*dt/mass

  allocate(da2(Nbase))
  do i=1,Nbase
   da2(i)=2*a(i)*d(i)
  enddo
  allocate(Mtype(Nbase))
  do i=1,Nbase
     if ((sequence(i)=='A').or.(sequence(i)=='T')) then 
        Mtype(i)=MtypAT
     else
         Mtype(i)=MtypGC
     endif
  enddo

  end subroutine  set_depvariables 
  !ES-----------------------------------------------------------------

  !BS----------------------------------------------------------------
  subroutine read_sequence
  use var
  use filrea
  implicit none
  integer::i,NL

  allocate(sequence(Nbase))
  allocate(a(Nbase))
  allocate(d(Nbase))

  call countlines(seqfile,NL)
  if (NL < Nbase) then
    print *,"Lines seqfile < Nbase"
    stop
  endif

  open(1,file=seqfile)
    do i=1,Nbase
      read(1,*) sequence(i)
    enddo
  close(1)
  
  do i=1,Nbase
    if( (sequence(i)=='A').or.(sequence(i)=='T')) then
      d(i) = dAT
      a(i) = aAT
    else if((sequence(i)=='G').or.(sequence(i)=='C')) then
      d(i) = dGC
      a(i) = aGC
    else
      write(*,*)' Sequence must be A, T, G, or C'
      stop
    endif
  enddo
  
  end subroutine read_sequence
  !ES-----------------------------------------------------------------

end Module setpar
!EM------------------------------------------------------------------------
